---
phase: 04-mcp-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [server/index.ts, package.json]
autonomous: false

must_haves:
  truths:
    - "Claude Code lists MCP tools and sees get_presentation, get_slide, execute_officejs"
    - "get_presentation returns JSON with slide IDs and shape summaries (count, names, types)"
    - "get_slide returns detailed shape data including text content, positions, sizes, and fill colors"
    - "execute_officejs sends arbitrary Office.js code to PowerPoint and returns the result"
    - "No console.log output corrupts MCP stdio transport"
  artifacts:
    - path: "server/index.ts"
      provides: "MCP server with 3 registered tools coexisting with HTTPS+WSS"
      contains: "McpServer|registerTool|StdioServerTransport"
    - path: "package.json"
      provides: "MCP SDK and Zod dependencies"
      contains: "@modelcontextprotocol/sdk"
  key_links:
    - from: "MCP tool handlers"
      to: "sendCommand('executeCode', ...)"
      via: "function call composing Office.js code strings"
      pattern: "sendCommand.*executeCode"
    - from: "StdioServerTransport"
      to: "process.stdin/stdout"
      via: "MCP JSON-RPC protocol (no console.log interference)"
      pattern: "StdioServerTransport"
    - from: "server startup logs"
      to: "process.stderr"
      via: "console.error replaces all console.log"
      pattern: "console\\.error"
---

<objective>
Add MCP stdio server to the existing bridge process, register three tools (get_presentation, get_slide, execute_officejs), and verify Claude Code can discover and use them to read and modify a live PowerPoint presentation.

Purpose: This is the final phase — it connects Claude Code to the bridge, completing the full pipeline: Claude Code -> MCP -> WebSocket -> Office.js -> PowerPoint.
Output: server/index.ts with MCP server and 3 tools; package.json with SDK dependencies.
</objective>

<execution_context>
@/Users/zarz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zarz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-tools/04-RESEARCH.md
@.planning/phases/03-command-execution/03-01-SUMMARY.md
@server/index.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MCP dependencies and add stdio server skeleton</name>
  <files>package.json, server/index.ts</files>
  <action>
Three changes:

**1. Install dependencies:**
```bash
cd /Users/zarz/dev/powerpoint-bridge && npm install @modelcontextprotocol/sdk zod
```

**2. Replace all `console.log` with `console.error` in server/index.ts.**
There are exactly 6 occurrences to change (lines 149, 175, 187, 200, 201, 202). The `console.error` calls already in the file (lines 23, 156, 191) stay as-is. This is critical — any `console.log` will write to stdout, which MCP uses for JSON-RPC messages, corrupting the protocol.

**3. Add MCP server skeleton to server/index.ts.**

Add these imports at the top of the file (after the existing imports):
```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
```

After the `server.listen()` block at the bottom of the file, add MCP server creation and connection:
```typescript
// ---------------------------------------------------------------------------
// MCP server (stdio transport — coexists with HTTPS+WSS on port 8443)
// ---------------------------------------------------------------------------

const mcpServer = new McpServer({
  name: "powerpoint-bridge",
  version: "0.1.0",
});

// [Tool registrations will go here — Task 2]

const transport = new StdioServerTransport();
await mcpServer.connect(transport);
console.error("MCP server connected via stdio");
```

Note: The file is already ESM (package.json has `"type": "module"`) and uses top-level await implicitly via Node 24's native TS execution, so `await mcpServer.connect(transport)` at module level is fine.
  </action>
  <verify>
1. `npm ls @modelcontextprotocol/sdk zod` shows both installed
2. `grep -c 'console\.log' server/index.ts` returns 0 (zero console.log remaining)
3. `grep -c 'console\.error' server/index.ts` returns at least 9 (original 3 + converted 6)
4. `npm run typecheck` passes with no errors
  </verify>
  <done>MCP SDK and Zod installed. All console.log replaced with console.error. MCP server skeleton added with StdioServerTransport connected. Typecheck passes.</done>
</task>

<task type="auto">
  <name>Task 2: Register get_presentation, get_slide, and execute_officejs tools</name>
  <files>server/index.ts</files>
  <action>
Register three tools on `mcpServer` between its creation and the `transport.connect()` call. Each tool calls `sendCommand('executeCode', { code })` which dispatches Office.js code to the add-in via WebSocket.

**Tool 1: get_presentation (no input params)**

Description: "Returns the structure of the currently open PowerPoint presentation including all slides with their IDs and shape summaries (count, names, types). Use this first to understand what's in the presentation before making changes."

Office.js code to compose and send:
```javascript
var slides = context.presentation.slides;
slides.load("items");
await context.sync();
for (var i = 0; i < slides.items.length; i++) {
  slides.items[i].shapes.load("items");
}
await context.sync();
var output = [];
for (var i = 0; i < slides.items.length; i++) {
  var slide = slides.items[i];
  var shapes = [];
  for (var j = 0; j < slide.shapes.items.length; j++) {
    var s = slide.shapes.items[j];
    shapes.push({ name: s.name, type: s.type, id: s.id });
  }
  output.push({ index: i, id: slide.id, shapeCount: shapes.length, shapes: shapes });
}
return output;
```

Wrap the sendCommand call in try/catch. On success return `{ content: [{ type: "text", text: JSON.stringify(result, null, 2) }] }`. On error return `{ content: [{ type: "text", text: "Error: " + err.message }], isError: true }`.

**Tool 2: get_slide (input: slideIndex as z.number().int().min(0))**

Description: "Returns detailed information about all shapes on a specific slide, including text content, positions (left, top in points), sizes (width, height in points), and fill colors. Use slideIndex from get_presentation results (zero-based)."

Input schema: `{ slideIndex: z.number().int().min(0).describe("Zero-based slide index from get_presentation results") }`

Office.js code to compose (inject slideIndex via template literal):
```javascript
var slides = context.presentation.slides;
slides.load("items");
await context.sync();
if (${slideIndex} >= slides.items.length) {
  throw new Error("Slide index " + ${slideIndex} + " out of range (presentation has " + slides.items.length + " slides)");
}
var slide = slides.items[${slideIndex}];
slide.shapes.load("items");
await context.sync();
var shapes = [];
for (var i = 0; i < slide.shapes.items.length; i++) {
  var s = slide.shapes.items[i];
  var info = {
    name: s.name,
    type: s.type,
    id: s.id,
    left: s.left,
    top: s.top,
    width: s.width,
    height: s.height
  };
  try {
    s.textFrame.load("textRange");
    await context.sync();
    info.text = s.textFrame.textRange.text;
  } catch (e) {
    // Shape has no text frame (e.g., images, connectors)
  }
  try {
    s.fill.load("foregroundColor,type");
    await context.sync();
    info.fill = { type: s.fill.type, color: s.fill.foregroundColor };
  } catch (e) {
    // Shape has no fill or fill not accessible
  }
  shapes.push(info);
}
return { slideIndex: ${slideIndex}, slideId: slide.id, shapes: shapes };
```

Same try/catch + MCP return format as Tool 1.

**Tool 3: execute_officejs (input: code as z.string())**

Description: "Execute arbitrary Office.js code inside the live PowerPoint presentation. The code runs inside PowerPoint.run(async (context) => { ... }) with 'context' available as a variable. Use 'await context.sync()' after loading properties. Return a value to get it back as the tool result. For positioning, all values are in points (1 point = 1/72 inch). Common operations: add shapes, set text, change colors, add/delete slides."

Input schema: `{ code: z.string().describe("Office.js code to execute. Runs inside PowerPoint.run() with 'context' available. Use 'return' to send back a result.") }`

This tool simply passes the code through:
```typescript
const result = await sendCommand('executeCode', { code });
return { content: [{ type: "text", text: JSON.stringify(result ?? { success: true }, null, 2) }] };
```

Same try/catch error handling pattern.

**Implementation notes:**
- Use `mcpServer.registerTool()` with 3 args: name string, options object (description + inputSchema), handler function
- For tools with no input params (get_presentation), omit inputSchema from options
- The handler receives destructured input params as first arg: `async ({ slideIndex })` or `async ({ code })`
- For get_presentation with no params, handler signature is `async () => { ... }`
- The Office.js code strings use `var` not `let`/`const` — this is intentional for WKWebView compatibility (decision KD-0202-1)
  </action>
  <verify>
1. `npm run typecheck` passes with no errors
2. `grep -c 'registerTool' server/index.ts` returns 3 (one per tool)
3. `grep 'get_presentation\|get_slide\|execute_officejs' server/index.ts` shows all three tool names
4. Start the server briefly to confirm no startup crash: `timeout 3 node server/index.ts < /dev/null 2>&1 || true` (will exit due to stdin close or timeout — either is fine; check stderr for "MCP server connected via stdio" message and no errors)
  </verify>
  <done>Three MCP tools registered: get_presentation (returns slide/shape overview), get_slide (returns detailed shape data with text/positions/colors), execute_officejs (passes arbitrary code to PowerPoint). All tools call sendCommand('executeCode', ...) and return MCP-formatted results. Typecheck passes.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete MCP integration: stdio server with 3 tools (get_presentation, get_slide, execute_officejs) coexisting with HTTPS+WSS bridge in a single Node.js process.</what-built>
  <how-to-verify>
1. Ensure PowerPoint is open with a presentation and the add-in taskpane shows "Connected"
2. Restart the bridge server if it was already running: `npm start` from project root
3. In Claude Code (a separate session), verify MCP tools are available:
   - The MCP config should point to: `{"command": "node", "args": ["server/index.ts"], "cwd": "/Users/zarz/dev/powerpoint-bridge"}`
   - Ask Claude Code to list its MCP tools — it should show get_presentation, get_slide, execute_officejs
4. Test get_presentation: ask Claude Code to read the presentation structure. It should return JSON with slide IDs and shape info.
5. Test get_slide: ask Claude Code to inspect slide 0. It should return shape details (text, positions, sizes).
6. Test execute_officejs: ask Claude Code to add a red rectangle to slide 1. The shape should appear in PowerPoint immediately.
7. Test round-trip: ask Claude Code to read slide 1 again and confirm it now includes the new rectangle.
  </how-to-verify>
  <resume-signal>Type "approved" if all MCP tools work correctly, or describe any issues encountered.</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run typecheck` — zero errors
2. `grep -c 'console\.log' server/index.ts` — returns 0
3. All three tools registered and callable via MCP protocol
4. Full round-trip verified: Claude Code -> MCP -> WSS -> Office.js -> PowerPoint -> response
</verification>

<success_criteria>
- Claude Code discovers get_presentation, get_slide, execute_officejs as MCP tools
- get_presentation returns slide array with shape summaries
- get_slide returns detailed shape properties (text, position, size, fill)
- execute_officejs modifies the live presentation and returns results
- HTTPS+WSS server on port 8443 continues serving the add-in alongside MCP stdio
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-tools/04-01-SUMMARY.md`
</output>
