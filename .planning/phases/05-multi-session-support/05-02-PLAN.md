---
phase: 05-multi-session-support
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - server/index.ts
  - .mcp.json
autonomous: false

must_haves:
  truths:
    - "Claude Code connects to the bridge via MCP HTTP transport at https://localhost:8443/mcp"
    - "list_presentations tool shows all currently connected presentations with file paths"
    - "Tools can target a specific presentation by presentationId when multiple are connected"
    - "Tools auto-target when only one presentation is connected (zero friction)"
    - "Multiple Claude Code sessions can connect simultaneously (per-session McpServer instances)"
    - "Warning shown once per session when targeting a presentation another session is also using"
  artifacts:
    - path: "server/index.ts"
      provides: "MCP HTTP transport, list_presentations tool, presentationId targeting"
      contains: "StreamableHTTPServerTransport"
    - path: ".mcp.json"
      provides: "Claude Code MCP configuration for HTTP transport"
      contains: "https://localhost:8443/mcp"
  key_links:
    - from: ".mcp.json"
      to: "server/index.ts /mcp route"
      via: "HTTPS POST to /mcp endpoint"
      pattern: "https://localhost:8443/mcp"
    - from: "server/index.ts /mcp route"
      to: "StreamableHTTPServerTransport"
      via: "handleRequest(req, res, parsedBody)"
      pattern: "handleMcpPost"
    - from: "server/index.ts registerTools"
      to: "resolveTarget"
      via: "presentationId parameter on tool calls"
      pattern: "resolveTarget.*presentationId"
---

<objective>
Replace the stdio MCP transport with Streamable HTTP transport on the existing HTTPS server, enabling multiple Claude Code sessions to connect simultaneously. Add a `list_presentations` tool and an optional `presentationId` parameter to all existing tools for explicit targeting. Update `.mcp.json` and configure TLS trust.

Purpose: This is the core multi-session enablement — multiple Claude Code processes connect to one long-running bridge server via HTTP, each getting its own MCP session.
Output: Working MCP HTTP endpoint at `/mcp`, new `list_presentations` tool, per-call targeting on all tools, updated configuration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-session-support/05-CONTEXT.md
@.planning/phases/05-multi-session-support/05-RESEARCH.md
@.planning/phases/05-multi-session-support/05-01-SUMMARY.md
@server/index.ts
@.mcp.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace stdio with HTTP transport and add targeting tools</name>
  <files>server/index.ts</files>
  <action>
  This is the main refactoring of server/index.ts. The changes are:

  **A. Update imports:**
  - Remove: `import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";`
  - Add:
    ```typescript
    import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
    import { isInitializeRequest } from "@modelcontextprotocol/sdk/types.js";
    ```

  **B. Add MCP session tracking** (near the connection pool declarations):
  ```typescript
  const mcpTransports = new Map<string, StreamableHTTPServerTransport>();

  // Track which sessions have been warned about concurrent access per presentation
  const sessionConcurrentWarnings = new Map<string, Set<string>>();
  ```

  **C. Extract tool registration into a factory function.**
  Create `function registerTools(server: McpServer): void` that registers all four tools (list_presentations + the three existing ones with presentationId param added).

  The `list_presentations` tool:
  ```typescript
  server.tool(
    "list_presentations",
    "Lists all PowerPoint presentations currently connected to the bridge server. Shows presentation IDs (file paths for saved files, generated IDs for unsaved) and connection status. Use this to find the presentationId to pass to other tools when multiple presentations are open.",
    async () => {
      const presentations = [];
      for (const [id, conn] of addinConnections) {
        presentations.push({
          presentationId: id,
          filePath: conn.filePath,
          ready: conn.ready,
        });
      }
      return {
        content: [{
          type: "text" as const,
          text: presentations.length === 0
            ? "No presentations connected. Open a PowerPoint file with the bridge add-in loaded."
            : JSON.stringify(presentations, null, 2)
        }]
      };
    }
  );
  ```

  For the three existing tools (`get_presentation`, `get_slide`, `execute_officejs`), add an optional `presentationId` parameter:
  - Add `presentationId: z.string().optional().describe("Target presentation ID from list_presentations. Optional when only one presentation is connected.")` to each tool's schema
  - In each handler, call `resolveTarget(presentationId)` instead of `resolveTarget()` to pass the optional parameter through

  For `get_slide`, the schema becomes:
  ```typescript
  {
    slideIndex: z.number().int().min(0).describe("Zero-based slide index from get_presentation results"),
    presentationId: z.string().optional().describe("Target presentation ID from list_presentations. Optional when only one presentation is connected.")
  }
  ```

  For `get_presentation`, add a schema (it currently has none — the 3-arg form with no schema):
  ```typescript
  { presentationId: z.string().optional().describe("Target presentation ID from list_presentations. Optional when only one presentation is connected.") }
  ```

  For `execute_officejs`:
  ```typescript
  {
    code: z.string().describe("Office.js code to execute. Runs inside PowerPoint.run() with 'context' available. Use 'return' to send back a result."),
    presentationId: z.string().optional().describe("Target presentation ID from list_presentations. Optional when only one presentation is connected.")
  }
  ```

  Each tool handler should call `resolveTarget(presentationId)` and use the returned connection's `ws` for `sendCommand`.

  **D. Add concurrent access warning helper:**
  ```typescript
  function getConcurrentWarning(mcpSessionId: string | undefined, presentationId: string): string | null {
    if (!mcpSessionId) return null;
    // Check if any OTHER MCP session is active (we can't perfectly track which
    // presentation each session targets, but we can warn when multiple sessions exist)
    if (mcpTransports.size <= 1) return null;

    const warned = sessionConcurrentWarnings.get(mcpSessionId);
    if (warned?.has(presentationId)) return null;

    if (!warned) {
      sessionConcurrentWarnings.set(mcpSessionId, new Set([presentationId]));
    } else {
      warned.add(presentationId);
    }

    return '\n\nNote: Other MCP sessions are also connected to the bridge. If they target this presentation, changes apply immediately (last-write-wins).';
  }
  ```

  In tool handlers for get_presentation, get_slide, and execute_officejs, append the warning to the response text if `getConcurrentWarning()` returns non-null. The warning only appears once per session per presentation.

  To pass the MCP session ID into tools: The `StreamableHTTPServerTransport` sets the `sessionId` property after initialization. When creating each McpServer in the factory, capture the associated transport's sessionId. The simplest approach: pass the transport reference to `registerTools` and read `transport.sessionId` inside tool handlers.

  Updated signature: `function registerTools(server: McpServer, getSessionId: () => string | undefined): void`

  In tool handlers, call `getConcurrentWarning(getSessionId(), target.presentationId)`.

  **E. Add HTTP request handling for /mcp:**

  Create `parseJsonBody`:
  ```typescript
  function parseJsonBody(req: IncomingMessage): Promise<unknown> {
    return new Promise((resolve, reject) => {
      const chunks: Buffer[] = [];
      req.on('data', (chunk: Buffer) => chunks.push(chunk));
      req.on('end', () => {
        try {
          resolve(JSON.parse(Buffer.concat(chunks).toString()));
        } catch {
          reject(new Error('Invalid JSON body'));
        }
      });
      req.on('error', reject);
    });
  }
  ```

  Create `handleMcpPost`:
  ```typescript
  async function handleMcpPost(req: IncomingMessage, res: ServerResponse): Promise<void> {
    try {
      const body = await parseJsonBody(req);
      const sessionId = req.headers['mcp-session-id'] as string | undefined;

      if (sessionId && mcpTransports.has(sessionId)) {
        await mcpTransports.get(sessionId)!.handleRequest(req, res, body);
      } else if (!sessionId && isInitializeRequest(body)) {
        const transport = new StreamableHTTPServerTransport({
          sessionIdGenerator: () => randomUUID(),
          onsessioninitialized: (sid) => {
            mcpTransports.set(sid, transport);
            console.error('MCP session initialized: ' + sid);
          },
        });
        transport.onclose = () => {
          const sid = transport.sessionId;
          if (sid) {
            mcpTransports.delete(sid);
            sessionConcurrentWarnings.delete(sid);
            console.error('MCP session closed: ' + sid);
          }
        };
        const server = createMcpSession(transport);
        await server.connect(transport);
        await transport.handleRequest(req, res, body);
      } else {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ jsonrpc: '2.0', error: { code: -32000, message: 'Bad request: no valid session' }, id: null }));
      }
    } catch (err) {
      console.error('MCP POST error:', err);
      if (!res.headersSent) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ jsonrpc: '2.0', error: { code: -32603, message: 'Internal error' }, id: null }));
      }
    }
  }
  ```

  Create `handleMcpGet` (for SSE streams — required by Streamable HTTP protocol):
  ```typescript
  async function handleMcpGet(req: IncomingMessage, res: ServerResponse): Promise<void> {
    const sessionId = req.headers['mcp-session-id'] as string | undefined;
    if (!sessionId || !mcpTransports.has(sessionId)) {
      res.writeHead(400, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ jsonrpc: '2.0', error: { code: -32000, message: 'Invalid or missing session ID' }, id: null }));
      return;
    }
    await mcpTransports.get(sessionId)!.handleRequest(req, res);
  }
  ```

  Create `handleMcpDelete` (for session termination):
  ```typescript
  async function handleMcpDelete(req: IncomingMessage, res: ServerResponse): Promise<void> {
    const sessionId = req.headers['mcp-session-id'] as string | undefined;
    if (!sessionId || !mcpTransports.has(sessionId)) {
      res.writeHead(400, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({ jsonrpc: '2.0', error: { code: -32000, message: 'Invalid or missing session ID' }, id: null }));
      return;
    }
    await mcpTransports.get(sessionId)!.handleRequest(req, res);
  }
  ```

  Create `createMcpSession` factory:
  ```typescript
  function createMcpSession(transport: StreamableHTTPServerTransport): McpServer {
    const server = new McpServer({
      name: "powerpoint-bridge",
      version: "0.2.0",
    });
    registerTools(server, () => transport.sessionId ?? undefined);
    return server;
  }
  ```

  **F. Replace the HTTPS request handler:**

  Change the `createServer` call to use a new `handleRequest` function instead of `serveStatic` directly:

  ```typescript
  function handleRequest(req: IncomingMessage, res: ServerResponse): void {
    const url = (req.url ?? '/').split('?')[0];

    if (url === '/mcp') {
      if (req.method === 'POST') { handleMcpPost(req, res); }
      else if (req.method === 'GET') { handleMcpGet(req, res); }
      else if (req.method === 'DELETE') { handleMcpDelete(req, res); }
      else { res.writeHead(405); res.end(); }
      return;
    }

    serveStatic(req, res);
  }

  const server = createServer({ cert, key }, handleRequest);
  ```

  **G. Remove the old stdio MCP code:**
  - Remove the entire block at the bottom of the file that creates `mcpServer`, registers tools on it, creates `StdioServerTransport`, and calls `mcpServer.connect(transport)`.
  - MCP servers are now created on-demand per HTTP session, not at startup.

  **H. Update server startup log:**
  Add MCP endpoint to the startup message:
  ```typescript
  server.listen(PORT, () => {
    console.error('Bridge server running');
    console.error(`  HTTPS: https://localhost:${PORT}`);
    console.error(`  WSS:   wss://localhost:${PORT}`);
    console.error(`  MCP:   https://localhost:${PORT}/mcp`);
  });
  ```

  **Important implementation notes:**
  - Use `var` only in Office.js code strings sent to the add-in. Server-side code uses `const`/`let` as before.
  - All console output uses `console.error` (not `console.log`) — there's no stdio MCP anymore, but this is a good convention to maintain.
  - Keep the global `pendingRequests` Map — UUID keys are globally unique across sessions.
  - The `resolveTarget()` function from plan 05-01 already handles single vs multi connection detection.
  </action>
  <verify>
  1. Run `npm run typecheck` — must pass with no errors.
  2. Start the server: `npm start` — verify it logs "Bridge server running" and the MCP endpoint URL.
  3. Test the /mcp endpoint responds:
     ```bash
     curl -k -X POST https://localhost:8443/mcp \
       -H "Content-Type: application/json" \
       -d '{"jsonrpc":"2.0","method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"0.1.0"}},"id":1}'
     ```
     Should return a JSON response with `serverInfo` and a `mcp-session-id` header.
  4. Verify no remaining references to `StdioServerTransport` in server/index.ts.
  </verify>
  <done>
  MCP HTTP transport running on /mcp endpoint. Per-session McpServer instances created on demand. list_presentations tool registered. All tools accept optional presentationId parameter. Concurrent access warnings tracked per session. Stdio transport fully removed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update configuration for HTTP transport and TLS trust</name>
  <files>.mcp.json</files>
  <action>
  1. **Update `.mcp.json`** to use HTTP transport instead of stdio:
     ```json
     {
       "mcpServers": {
         "powerpoint-bridge": {
           "type": "http",
           "url": "https://localhost:8443/mcp"
         }
       }
     }
     ```

  2. **Configure TLS trust for Claude Code.** Claude Code's Node.js runtime doesn't trust mkcert's local CA by default. Run:
     ```bash
     CAROOT=$(mkcert -CAROOT)
     ```
     Then check if `~/.claude/settings.json` exists. If it does, read it and merge the `env` key. If it doesn't, create it. The result should include:
     ```json
     {
       "env": {
         "NODE_EXTRA_CA_CERTS": "<CAROOT>/rootCA.pem"
       }
     }
     ```
     Where `<CAROOT>` is the actual path from `mkcert -CAROOT` (e.g., `$(mkcert -CAROOT)`).

     **Be careful:** `~/.claude/settings.json` may have other existing settings. Read it first, merge the `env.NODE_EXTRA_CA_CERTS` key, and write back. Do NOT overwrite other keys.

  3. **Update `package.json` version** from `0.1.0` to `0.2.0` to reflect the major architecture change (stdio -> HTTP).
  </action>
  <verify>
  1. Read `.mcp.json` — confirm it has `type: "http"` and `url: "https://localhost:8443/mcp"`.
  2. Read `~/.claude/settings.json` — confirm `NODE_EXTRA_CA_CERTS` points to `<mkcert CAROOT>/rootCA.pem`.
  3. Read `package.json` — confirm version is `0.2.0`.
  </verify>
  <done>
  .mcp.json points to HTTP MCP endpoint. Claude Code configured to trust mkcert's local CA certificate. Package version bumped to 0.2.0.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete multi-session MCP HTTP server with:
  - Multi-connection WebSocket pool tracking multiple PowerPoint add-ins
  - MCP HTTP transport at https://localhost:8443/mcp (replacing stdio)
  - `list_presentations` tool showing connected presentations
  - Optional `presentationId` parameter on all tools
  - Auto-detect targeting for single-presentation case
  - Per-session MCP instances for concurrent Claude Code sessions
  </what-built>
  <how-to-verify>
  1. Start the bridge server: `npm start`
  2. Open a PowerPoint presentation with the add-in loaded — the taskpane should show "Connected"
  3. In a NEW Claude Code session (important: /clear first, then restart), verify the MCP tools are available:
     - Call `list_presentations` — should show the connected presentation
     - Call `get_presentation` — should return slide/shape data
     - Call `execute_officejs` with simple code like `var c = context.presentation.slides.getCount(); await context.sync(); return c.value;` — should return slide count
  4. If you have a second PowerPoint file, open it too and verify `list_presentations` shows both
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. Server starts and logs MCP endpoint URL
3. POST to /mcp with initialize request returns 200 with session ID
4. No references to `StdioServerTransport` remain in server/index.ts
5. `.mcp.json` uses HTTP transport type
6. `list_presentations` tool is registered and returns connected presentations
7. Existing tools accept optional `presentationId` parameter
8. `addinConnections` Map tracks connections by presentation identity
</verification>

<success_criteria>
- MCP HTTP transport fully replaces stdio transport
- Multiple Claude Code sessions can connect simultaneously
- list_presentations shows all connected add-in instances
- Tools target specific presentations or auto-detect single connection
- Configuration updated for HTTP transport and TLS trust
- Backward compatible: single-presentation use case works with zero friction
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-session-support/05-02-SUMMARY.md`
</output>
