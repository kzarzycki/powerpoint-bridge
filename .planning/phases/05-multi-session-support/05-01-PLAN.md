---
phase: 05-multi-session-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/index.ts
  - addin/app.js
autonomous: true

must_haves:
  truths:
    - "Server tracks multiple connected PowerPoint add-in instances simultaneously"
    - "Each add-in reports its presentation identity (file path or generated ID) on connect"
    - "Existing MCP tools still work with a single connected add-in (backward compatible)"
    - "Disconnecting one add-in does not affect other connected add-ins"
  artifacts:
    - path: "server/index.ts"
      provides: "Multi-connection WebSocket pool with AddinConnection tracking"
      contains: "addinConnections"
    - path: "addin/app.js"
      provides: "Presentation identity reporting in ready message"
      contains: "documentUrl"
  key_links:
    - from: "addin/app.js"
      to: "server/index.ts"
      via: "WebSocket ready message with documentUrl field"
      pattern: "documentUrl"
    - from: "server/index.ts sendCommand"
      to: "addinConnections Map"
      via: "Target WebSocket lookup by presentationId"
      pattern: "addinConnections"
---

<objective>
Replace the single-connection model (`addinClient`/`addinReady`) with a multi-connection WebSocket pool that tracks multiple PowerPoint add-in instances by presentation identity. The add-in reports its file path (or null for unsaved) in the ready message, and the server assigns a stable identifier.

Purpose: Foundation for multi-session support — the server must track multiple add-ins before MCP can target them.
Output: Refactored server/index.ts with connection pool, updated addin/app.js with identity reporting. Existing stdio MCP tools continue working unchanged.
</objective>

<execution_context>
@/Users/zarz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zarz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-session-support/05-CONTEXT.md
@.planning/phases/05-multi-session-support/05-RESEARCH.md
@server/index.ts
@addin/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor server/index.ts to multi-connection WebSocket pool</name>
  <files>server/index.ts</files>
  <action>
  Replace the single-connection tracking variables with a connection pool:

  1. **Remove** the single-connection variables:
     - Delete `let addinClient: WebSocket | null = null;`
     - Delete `let addinReady = false;`

  2. **Add** connection pool data structures (after `COMMAND_TIMEOUT`):
     ```typescript
     interface AddinConnection {
       ws: WebSocket;
       ready: boolean;
       presentationId: string;
       filePath: string | null;
     }

     const addinConnections = new Map<string, AddinConnection>();
     let untitledCounter = 0;
     ```

  3. **Refactor `sendCommand()`** to accept a target connection:
     - Change signature to `sendCommand(action: string, params: Record<string, unknown>, targetWs: WebSocket): Promise<unknown>`
     - Remove the `addinClient` and `addinReady` checks
     - Replace `addinClient!.send(...)` with `targetWs.send(...)`
     - The caller is responsible for providing a valid, ready WebSocket

  4. **Add `resolveTarget()` function** (after sendCommand):
     ```typescript
     function resolveTarget(presentationId?: string): AddinConnection {
       if (addinConnections.size === 0) {
         throw new Error('No presentations connected. Open a PowerPoint file with the bridge add-in loaded.');
       }
       if (presentationId) {
         var conn = addinConnections.get(presentationId);
         if (!conn) throw new Error('Presentation not found: ' + presentationId + '. Use list_presentations to see connected presentations.');
         if (!conn.ready) throw new Error('Presentation connected but not ready: ' + presentationId);
         return conn;
       }
       if (addinConnections.size === 1) {
         var single = addinConnections.values().next().value!;
         if (!single.ready) throw new Error('Add-in connected but not ready');
         return single;
       }
       var ids = [...addinConnections.keys()];
       throw new Error('Multiple presentations connected. Specify presentationId parameter. Available: ' + ids.join(', '));
     }
     ```
     Note: Use `var` for local variables inside the function to match the `erasableSyntaxOnly` pattern. Actually, `var` vs `const` doesn't matter for server-side Node.js code — that constraint only applies to Office.js code strings sent to WKWebView. Use `const` for server code as before.

  5. **Update WebSocket `connection` handler** to track connections by identity:
     - On connection: store `ws` reference temporarily (not yet in pool — wait for ready message)
     - On `ready` message: extract `documentUrl` from the message data. If `documentUrl` is a non-empty string, use it as `presentationId` and `filePath`. Otherwise generate `'untitled-' + (++untitledCounter)` as `presentationId` with `filePath: null`. Add to `addinConnections` Map. Log: `console.error('Add-in ready: ' + presentationId);`
     - On `close`: find which connection disconnected by searching the Map for matching `ws`. Remove it. Only reject pending requests that were sent to THIS specific WebSocket (don't clear all pending requests). Log: `console.error('Add-in disconnected: ' + presentationId);`
     - Keep the `response`/`error` message handling as-is (pendingRequests is global, keyed by UUID)

  6. **Update `/api/test` endpoint** to use resolveTarget:
     - Replace direct `sendCommand(...)` call with:
       ```typescript
       const target = resolveTarget();
       sendCommand('executeCode', { code: '...' }, target.ws)
       ```
     - Catch resolveTarget errors and return 500 with the error message

  7. **Update existing MCP tool handlers** to use resolveTarget:
     - In `get_presentation`, `get_slide`, and `execute_officejs`: replace `sendCommand('executeCode', { code })` with:
       ```typescript
       const target = resolveTarget();
       const result = await sendCommand('executeCode', { code }, target.ws);
       ```
     - Do NOT add `presentationId` parameter yet — that comes in plan 05-02

  8. **Handle pending request cleanup on disconnect:**
     - When a WebSocket closes, iterate `pendingRequests` and reject any whose command was sent to the disconnecting WebSocket. This requires tracking which WebSocket a pending request was sent to.
     - Add a `ws` field to `PendingRequest` interface: `ws: WebSocket;`
     - In `sendCommand`, set `pending.ws = targetWs` when storing the pending request
     - In the `close` handler, iterate pendingRequests and reject+delete entries where `pending.ws === ws`
  </action>
  <verify>
  Run `npm run typecheck` — must pass with no errors.
  Run `node -e "import('./server/index.ts')" 2>&1 | head -5` — server should start (will log "Bridge server running" to stderr). Kill it after verifying startup.
  </verify>
  <done>
  server/index.ts uses `addinConnections` Map instead of single `addinClient`. `sendCommand()` accepts a target WebSocket. `resolveTarget()` auto-detects single connection or errors with helpful messages. WebSocket handler registers connections by presentationId from ready message. All three MCP tools call `resolveTarget()` before `sendCommand()`. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add presentation identity reporting to add-in</name>
  <files>addin/app.js</files>
  <action>
  Update the `ws.onopen` handler in addin/app.js to include the presentation's file path in the ready message:

  1. **Modify `ws.onopen`** in the `connect()` function:
     ```javascript
     ws.onopen = function() {
       reconnectAttempt = 0;
       updateStatus('connected');
       console.log('WebSocket connected');
       var documentUrl = null;
       try {
         documentUrl = Office.context.document.url || null;
       } catch (e) {
         // Not available in standalone/browser mode
       }
       ws.send(JSON.stringify({ type: 'ready', documentUrl: documentUrl }));
     };
     ```

  This sends the file path (e.g., `/Users/zarz/Documents/Presentation1.pptx`) for saved files, or `null` for unsaved/standalone mode. The server uses this to identify the presentation.

  Do NOT change any other part of app.js. The existing reconnect logic, command handler, and executeCode function remain unchanged.
  </action>
  <verify>
  Read addin/app.js and confirm the `ws.onopen` handler sends `{ type: 'ready', documentUrl: ... }`.
  Verify the rest of the file (reconnect, handleCommand, executeCode) is unchanged.
  </verify>
  <done>
  addin/app.js sends presentation identity (file path or null) in the WebSocket ready message. Server can use this to register the connection in the connection pool.
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no errors
2. Server starts without crash: `npm start` logs "Bridge server running" to stderr
3. Grep confirms no remaining references to `addinClient` or `addinReady` in server/index.ts
4. addin/app.js sends `documentUrl` in ready message
5. MCP tools still reference `resolveTarget()` before sending commands
</verification>

<success_criteria>
- Single-connection model fully replaced with multi-connection pool
- Add-in reports presentation identity on connect
- All existing tools work through resolveTarget() auto-detection
- TypeScript compiles cleanly
- No behavioral regression for single-presentation use case
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-session-support/05-01-SUMMARY.md`
</output>
