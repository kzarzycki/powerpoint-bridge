---
phase: 03-command-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [server/index.ts, addin/app.js]
autonomous: false

must_haves:
  truths:
    - "Server tracks a connected add-in client and its ready state"
    - "sendCommand() sends a JSON command with UUID and returns a Promise that resolves with the add-in's response"
    - "Add-in receives commands, executes Office.js code inside PowerPoint.run(), and returns results via WebSocket"
    - "Errors during code execution return structured error objects with message, code, and debugInfo"
    - "Pending requests are cleaned up on disconnect and on timeout"
    - "A test command (get slide count) sent via /api/test returns correct data from the live, open presentation"
  artifacts:
    - path: "server/index.ts"
      provides: "Command sending, response dispatch, pending request tracking"
      contains: "sendCommand"
    - path: "addin/app.js"
      provides: "Command execution engine with AsyncFunction + PowerPoint.run()"
      contains: "executeCode"
  key_links:
    - from: "server/index.ts"
      to: "addin/app.js"
      via: "WebSocket JSON messages"
      pattern: "ws\\.send.*type.*command"
    - from: "addin/app.js"
      to: "server/index.ts"
      via: "WebSocket response/error/ready messages"
      pattern: "ws\\.send.*type.*response|error|ready"
    - from: "server/index.ts sendCommand()"
      to: "server/index.ts pendingRequests"
      via: "Promise resolve/reject stored in Map keyed by request ID"
      pattern: "pendingRequests\\.set"
---

<objective>
Wire up the JSON command protocol and Office.js code execution engine so the server can send code strings to the add-in and receive structured results.

Purpose: This is the core plumbing that Phase 4's MCP tools will use. The server's `sendCommand()` function will be called by MCP tool handlers to execute arbitrary Office.js code inside PowerPoint.

Output: Modified `server/index.ts` with command infrastructure and modified `addin/app.js` with execution engine.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-command-execution/03-RESEARCH.md

@server/index.ts
@addin/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add command infrastructure to bridge server</name>
  <files>server/index.ts</files>
  <action>
Modify `server/index.ts` to add the command sending and response dispatch infrastructure. All additions go into the existing file — do NOT rewrite unrelated parts.

**Add import** at the top alongside existing imports:
```
import { randomUUID } from 'node:crypto';
```

**Add after the MIME type section** (before the static file handler):

1. A `PendingRequest` interface with `resolve: (data: unknown) => void`, `reject: (err: Error) => void`, `timer: ReturnType<typeof setTimeout>`.

2. Module-level state:
   - `const pendingRequests = new Map<string, PendingRequest>();`
   - `const COMMAND_TIMEOUT = 30_000;`
   - `let addinClient: WebSocket | null = null;`
   - `let addinReady = false;`

3. A `sendCommand(action: string, params: Record<string, unknown>): Promise<unknown>` function that:
   - Rejects immediately if `addinClient` is null or not in OPEN state (readyState !== 1)
   - Rejects immediately if `addinReady` is false
   - Generates a UUID via `randomUUID()`
   - Creates a timeout that deletes the pending request and rejects after `COMMAND_TIMEOUT`
   - Stores `{resolve, reject, timer}` in `pendingRequests` keyed by ID
   - Sends `{type: 'command', id, action, params}` as JSON via `addinClient.send()`

**Replace the existing `wss.on('connection')` handler** with one that:

1. Sets `addinClient = ws` and logs connection.

2. On `message`: Parses JSON. If `msg.type` is `'response'` or `'error'` and `msg.id` exists, looks up `pendingRequests.get(msg.id)`. If found: clears timer, deletes from map, resolves (for response with `msg.data`) or rejects (for error with `new Error(msg.error?.message || 'Command failed')`). If `msg.type` is `'ready'`: sets `addinReady = true` and logs "Add-in ready to receive commands".

3. On `close`: Iterates all `pendingRequests`, clears each timer, rejects each with `new Error('Add-in disconnected')`, then clears the map. Sets `addinClient = null` and `addinReady = false`. Logs disconnection.

4. On `error`: Logs error message (same as existing).

**Add a `/api/test` endpoint** to the existing `serveStatic` handler. Before the path traversal check, add: if `rawUrl === '/api/test'`, call `sendCommand('executeCode', { code: 'var c = context.presentation.slides.getCount(); await context.sync(); return c.value;' })`. On success, write `200` with `Content-Type: application/json` and body `JSON.stringify({ slideCount: result })`. On error, write `500` with the error message as JSON `{ error: err.message }`. This enables verifying the full round-trip from an HTTP request through to PowerPoint and back.

Keep all existing code (cert check, MIME types, static handler, HTTPS server, server.listen) untouched.
  </action>
  <verify>
Run `npx tsc --noEmit` — must pass with zero errors.
Run `node --import tsx server/index.ts &` then immediately kill it — must print "Bridge server running" without crashes.
  </verify>
  <done>server/index.ts has sendCommand(), pendingRequests Map, addinClient/addinReady tracking, response dispatch, and disconnect cleanup. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Add command execution engine to add-in</name>
  <files>addin/app.js</files>
  <action>
Modify `addin/app.js` to implement the command execution engine. All additions go into the existing file — do NOT rewrite unrelated parts.

**Add after the variable declarations** (after `var officeReady = false;`):
```javascript
var AsyncFunction = (async function(){}).constructor;
```

**Modify `ws.onopen`** to send a ready signal after setting status:
After `console.log('WebSocket connected');`, add:
```javascript
ws.send(JSON.stringify({ type: 'ready' }));
```
This tells the server the add-in can receive commands.

**Replace the `handleCommand` stub** with a real implementation:
```javascript
function handleCommand(message) {
  if (message.type !== 'command' || !message.id) return;

  if (message.action === 'executeCode') {
    executeCode(message.params.code, message.id);
  } else {
    sendError(message.id, { message: 'Unknown action: ' + message.action });
  }
}
```

**Add three new functions** after `handleCommand`:

1. `executeCode(code, requestId)`:
   - Calls `PowerPoint.run(async function(context) { ... })` (or if `typeof PowerPoint === 'undefined'`, reject with error "PowerPoint not available — running in standalone mode")
   - Inside PowerPoint.run: creates `var fn = new AsyncFunction('context', 'PowerPoint', code);`, calls `var result = await fn(context, PowerPoint);`, returns `result`.
   - `.then(function(result) { sendResponse(requestId, result === undefined ? null : result); })`
   - `.catch(function(error) { ... })` — extracts `error.message || String(error)`, `error.code || 'UnknownError'`, and `error.debugInfo || null` into a plain object, passes to `sendError(requestId, errorObj)`.

2. `sendResponse(id, data)`:
   - If `ws && ws.readyState === WebSocket.OPEN`: sends `JSON.stringify({ type: 'response', id: id, data: data })`.

3. `sendError(id, error)`:
   - If `ws && ws.readyState === WebSocket.OPEN`: sends `JSON.stringify({ type: 'error', id: id, error: error })`.

**Important constraints (from research anti-patterns):**
- Use `var` for all declarations (not const/let) — WKWebView compatibility per KD-0202-1
- Use `function` declarations (not arrow functions) — same reason
- The standalone mode check (`typeof PowerPoint === 'undefined'`) prevents crashes during browser testing
- Error objects must be manually destructured (message, code, debugInfo) because Error properties are non-enumerable
  </action>
  <verify>
Open `https://localhost:8443` in browser with server running. Open browser console. Verify:
1. No JavaScript syntax errors on page load
2. Console shows "WebSocket connected"
3. Server console shows "Add-in ready to receive commands"
  </verify>
  <done>addin/app.js has working handleCommand(), executeCode() with AsyncFunction + PowerPoint.run(), sendResponse(), sendError(), and ready signal on connect. Browser loads without errors.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify test command executes in live PowerPoint</name>
  <what-built>Command execution pipeline: server sendCommand() sends JSON commands over WebSocket, add-in executeCode() runs Office.js code inside PowerPoint.run(), results flow back as JSON responses. A /api/test endpoint triggers a slide count command for easy verification.</what-built>
  <how-to-verify>
    1. Start the bridge server: `npm start` (should print "Bridge server running on https://localhost:8443")
    2. Open PowerPoint and click the "PowerPoint Bridge" add-in in the ribbon (sideloaded in Phase 2)
    3. Confirm the add-in taskpane shows "Connected" and the server console prints "Add-in ready to receive commands"
    4. Open or create a presentation with a known number of slides (e.g., 3 slides)
    5. Visit `https://localhost:8443/api/test` in your browser
    6. Verify the JSON response contains `{"slideCount": 3}` (matching your actual slide count)
    7. If the response shows an error, check the server console and add-in taskpane for diagnostics
  </how-to-verify>
  <resume-signal>Type "approved" if the slide count matches, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — TypeScript compiles cleanly
2. Server starts and prints "Bridge server running" on port 8443
3. Opening `https://localhost:8443` in browser shows "Connected" status
4. Server console prints "Add-in ready to receive commands" when browser connects
5. No JavaScript errors in browser console on the add-in page
6. Visiting `https://localhost:8443/api/test` with PowerPoint connected returns correct slide count JSON (verified by user at checkpoint)
</verification>

<success_criteria>
- server/index.ts exports a working sendCommand() that Phase 4 MCP tools can call
- addin/app.js executes code strings inside PowerPoint.run() and returns structured JSON results
- The ready signal, response dispatch, and error handling form a complete request-response cycle
- Pending requests are cleaned up on timeout and disconnect (no memory leaks)
- A test command (get slide count) sent via /api/test returns correct data from the live, open presentation (verified at checkpoint)
</success_criteria>

<output>
After completion, create `.planning/phases/03-command-execution/03-01-SUMMARY.md`
</output>
